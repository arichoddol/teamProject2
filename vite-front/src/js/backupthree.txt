#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 resolution;

const int complexity = 7;        // 더 복잡하게
const float fluid_speed = 6.0;   // 약간 느리게 → 더 무겁고 강한 느낌
const float distortion = 1.2;    // ★ 뒤틀림 강도 2배 증가

// HSV → RGB 변환
vec3 hsv2rgb(vec3 c) {
    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0),
    6.0) - 3.0) - 1.0,
    0.0,
    1.0);
    return c.z * mix(vec3(1.0), rgb, c.y);
}

// 회전 (소용돌이 효과)
vec2 rotate2D(vec2 p, float a) {
    float s = sin(a);
    float c = cos(a);
    return mat2(c, -s, s, c) * p;
}

void main() {
    vec2 uv = (gl_FragCoord.xy * 2.0 - resolution.xy) /
        min(resolution.x, resolution.y);

    // 시간에 따라 화면 자체가 천천히 회전 (소용돌이)
    uv = rotate2D(uv, time * 0.15);

    vec2 baseUv = uv;

    
    for (int i = 1; i < complexity; i++) {

        float t = time / fluid_speed;

        uv.x += distortion * 0.9 / float(i) *
            sin(float(i) * baseUv.y * 3.5 + t * 2.0);

        uv.y += distortion * 0.9 / float(i) *
            cos(float(i) * baseUv.x * 3.0 + t * 2.5);

        // 유체 같은 누적 왜곡 추가
        baseUv += 0.15 * vec2(
            sin(baseUv.y * 4.0 + t),
            cos(baseUv.x * 4.0 + t)
        );
    }

    // UV 축소 (너무 튀지 않게)
    uv *= 0.75;

    // -------------------------------
    //   네온 블루 계열 생성
    // -------------------------------

    // 파란색 계열 여러 hue 섞기
    float hue1 = 0.60 + 0.05 * sin(time * 0.4 + uv.x * 3.0);
    float hue2 = 0.52 + 0.06 * sin(time * 0.7 + uv.y * 4.0);
    float hue3 = 0.72 + 0.08 * sin(time * 0.5 + uv.x * uv.y * 4.0);

    float hue = (hue1 + hue2 + hue3) / 3.0;

    vec3 neonBlue = hsv2rgb(vec3(hue, 1.0, 1.0));

    neonBlue = max(neonBlue, vec3(0.2));

    gl_FragColor = vec4(neonBlue, 1.0);
}